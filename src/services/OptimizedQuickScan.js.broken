/**
 * Optimized Quick Scan Service
 * Fast, contract-focused data fetching with deployment detection
 * 
 * Features:
 * - Fetches 1 week of data (50k-100k blocks)
 * - Detects contract deployment date
 * - Scans only contract-related: transactions, events, accounts, blocks
 * - Fast execution (30-60 seconds)
 */

export class OptimizedQuickScan {
  constructor(fetcher, config = {}) {
    this.fetcher = fetcher;
    this.config = {
      weekInBlocks: config.weekInBlocks || 10000, // ~1-2 days (optimized)
      maxScanBlocks: config.maxScanBlocks || 10000, // Max 10k blocks
      minScanBlocks: config.minScanBlocks || 5000, // Min 5k blocks
      chunkSize: config.chunkSize || 5000, // Chunk size for parallel fetching
      batchSize: config.batchSize || 10, // Batch transaction fetching
      maxRetries: config.maxRetries || 3, // Retry failed RPC calls
      retryDelay: config.retryDelay || 1000, // Initial retry delay (ms)
      cacheTimeout: config.cacheTimeout || 30000, // Cache timeout (30s)
      onProgress: config.onProgress || null, // Progress callback
      ...config
    };
    
    // Cache for block numbers
    this.blockNumberCache = {
      value: null,
      timestamp: null
    };
  }

  /**
   * Emit progress update
   * @private
   */
  _emitProgress(step, progress, message, data = {}) {
    const progressData = {
      step,
      progress, // 0-100
      message,
      timestamp: new Date().toISOString(),
      ...data
    };

    // Console logging
    console.log(`   üìä [${progress}%] ${message}`);

    // Callback for frontend
    if (this.config.onProgress && typeof this.config.onProgress === 'function') {
      this.config.onProgress(progressData);
    }
  }

  /**
   * Get cached block number or fetch new one
   * @private
   */
  async _getCachedBlockNumber(chain) {
    const now = Date.now();
    
    // Return cached value if still valid
    if (this.blockNumberCache.value && 
        this.blockNumberCache.timestamp && 
        (now - this.blockNumberCache.timestamp) < this.config.cacheTimeout) {
      console.log(`   üíæ Using cached block number: ${this.blockNumberCache.value}`);
      return this.blockNumberCache.value;
    }
    
    // Fetch new block number with timeout
    const blockNumber = await this._withTimeout(
      this.fetcher.getCurrentBlockNumber(chain),
      15000,
      'Block number fetch timeout'
    );
    
    // Update cache
    this.blockNumberCache = {
      value: blockNumber,
      timestamp: now
    };
    
    return blockNumber;
  }

  /**
   * Retry logic with exponential backoff
   * @private
   */
  async _withRetry(fn, retries = this.config.maxRetries) {
    let lastError;
    
    for (let i = 0; i < retries; i++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error;
        if (i < retries - 1) {
          const delay = this.config.retryDelay * Math.pow(2, i);
          console.log(`   ‚ö†Ô∏è  Retry ${i + 1}/${retries} after ${delay}ms: ${error.message}`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
    
    throw lastError;
  }

  /**
   * Add timeout to promise
   * @private
   */
  async _withTimeout(promise, timeoutMs, errorMessage) {
    const timeoutPromise = new Promise((_, reject) => 
      setTimeout(() => reject(new Error(errorMessage)), timeoutMs)
    );
    return Promise.race([promise, timeoutPromise]);
  }

  /**
   * Fetch data in chunks with parallel processing
   * @private
   */
  async _fetchInChunks(contractAddress, chain, fromBlock, toBlock) {
    const chunks = [];
    const chunkSize = this.config.chunkSize;
    
    // Create chunks
    for (let start = fromBlock; start <= toBlock; start += chunkSize) {
      const end = Math.min(start + chunkSize - 1, toBlock);
      chunks.push({ start, end });
    }
    
    console.log(`   üì¶ Split into ${chunks.length} chunks of ${chunkSize} blocks`);
    
    const allTransactions = [];
    const allEvents = [];
    
    // Process chunks in parallel (max 3 concurrent)
    const maxConcurrent = 3;
    for (let i = 0; i < chunks.length; i += maxConcurrent) {
      const batch = chunks.slice(i, i + maxConcurrent);
      const progress = 20 + Math.floor((i / chunks.length) * 60);
      
      this._emitProgress('fetching', progress, 
        `Fetching chunk ${i + 1}-${Math.min(i + maxConcurrent, chunks.length)} of ${chunks.length}...`
      );
      
      const results = await Promise.all(
        batch.map(chunk => 
          this._withRetry(() => 
            this._fetchChunkData(contractAddress, chain, chunk.start, chunk.end)
          )
        )
      );
      
      // Merge results
      results.forEach(result => {
        allTransactions.push(...result.transactions);
        allEvents.push(...result.events);
      });
    }
    
    return { transactions: allTransactions, events: allEvents };
  }

  /**
   * Fetch data for a single chunk
   * @private
   */
  async _fetchChunkData(contractAddress, chain, fromBlock, toBlock) {
    console.log(`   üîç Fetching chunk: ${fromBlock}-${toBlock}`);
    
    // Fetch transactions and events in parallel
    const [txData] = await Promise.all([
      this._withTimeout(
        this.fetcher.fetchTransactions(contractAddress, fromBlock, toBlock, chain),
        30000,
        'Transaction fetch timeout'
      )
    ]);
    
    return {
      transactions: txData.transactions || [],
      events: txData.events || []
    };
  }

  /**
   * Fast Quick Scan - 1 week of contract data with deployment detection
   * @param {string} contractAddress - Contract address
   * @param {string} chain - Blockchain network
   * @returns {Promise<Object>} Scan results with deployment info
   */
  async quickScan(contractAddress, chain) {
    console.log(`\n‚ö° OPTIMIZED QUICK SCAN - Contract-Focused Analysis`);
    console.log('========================================================');
    console.log(`üìç Contract: ${contractAddress}`);
    console.log(`üîó Chain: ${chain}`);
    
    const startTime = Date.now();
    const results = {
      contractAddress,
      chain,
      deploymentInfo: null,
      transactions: [],
      events: [],
      accounts: new Set(),
      blocks: new Set(),
      metrics: {
        totalTransactions: 0,
        totalEvents: 0,
        uniqueAccounts: 0,
        uniqueBlocks: 0,
        scanDuration: 0,
        blockRange: { from: 0, to: 0 },
        dataQuality: 'high'
      }
    };

    try {
      // Step 1: Get current block with caching and timeout
      this._emitProgress('init', 5, 'Getting current block number...');
      const currentBlock = await this._getCachedBlockNumber(chain);
      console.log(`üìä Current block: ${currentBlock.toLocaleString()}`);

      // Step 2: Calculate optimized scan range (10k blocks = 1-2 days)
      this._emitProgress('init', 10, 'Calculating block range...');
      const scanBlocks = Math.min(this.config.weekInBlocks, this.config.maxScanBlocks);
      const fromBlock = Math.max(0, currentBlock - scanBlocks);
      const toBlock = currentBlock;
      
      results.metrics.blockRange = { from: fromBlock, to: toBlock };
      
      console.log(`üìÖ Scanning last 1-2 days: ${fromBlock.toLocaleString()} ‚Üí ${toBlock.toLocaleString()}`);
      console.log(`üì¶ Total blocks: ${(toBlock - fromBlock).toLocaleString()}`);
      console.log(`üì¶ Chunks: ${Math.ceil((toBlock - fromBlock) / this.config.chunkSize)}\n`);

      // Step 3: Fetch data in parallel chunks with retry
      this._emitProgress('fetching', 20, 'Fetching contract data in parallel chunks...');
      
      const { transactions, events } = await this._fetchInChunks(
        contractAddress, 
        chain, 
        fromBlock, 
        toBlock
      );
      
      results.transactions = transactions;
      results.events = events;
      
      console.log(`‚úÖ Fetched ${transactions.length} transactions, ${events.length} events`);
      
      // Step 4: Process accounts and blocks
      this._emitProgress('processing', 85, 'Processing accounts and blocks...');
      
      transactions.forEach(tx => {
        results.accounts.add(tx.from);
        if (tx.to) results.accounts.add(tx.to);
        results.blocks.add(tx.blockNumber);
      });
      
      events.forEach(event => {
        results.blocks.add(event.blockNumber);
      });
      
      // Step 5: Calculate metrics
      this._emitProgress('finalizing', 95, 'Calculating metrics...');
      
      results.metrics.totalTransactions = transactions.length;
      results.metrics.totalEvents = events.length;
      results.metrics.uniqueAccounts = results.accounts.size;
      results.metrics.uniqueBlocks = results.blocks.size;
      results.metrics.scanDuration = Date.now() - startTime;
      
      // Convert Sets to Arrays for JSON serialization
      results.accounts = Array.from(results.accounts);
      results.blocks = Array.from(results.blocks);
      
      this._emitProgress('complete', 100, 'Quick scan complete!');
      
      console.log(`\n‚úÖ QUICK SCAN COMPLETE`);
      console.log(`‚è±Ô∏è  Duration: ${(results.metrics.scanDuration / 1000).toFixed(2)}s`);
      console.log(`üìä Transactions: ${results.metrics.totalTransactions}`);
      console.log(`üìã Events: ${results.metrics.totalEvents}`);
      console.log(`üë• Unique Accounts: ${results.metrics.uniqueAccounts}`);
      console.log(`üì¶ Unique Blocks: ${results.metrics.uniqueBlocks}`);
      
      return results;
      
    } catch (error) {
      console.error(`‚ùå Quick scan failed:`, error);
      this._emitProgress('error', 0, `Scan failed: ${error.message}`);
      throw error;
    }
  }
      });
      
      console.log(`üîç Step 1/3: Fetching contract events...`);
      const eventsData = await this._fetchContractEvents(contractAddress, fromBlock, toBlock, chain);
      
      results.events = eventsData.events;
      results.transactions = eventsData.transactions;
      results.metrics.totalEvents = eventsData.events.length;
      results.metrics.totalTransactions = eventsData.transactions.length;
      
      this._emitProgress('fetching', 60, `Found ${eventsData.transactions.length} transactions and ${eventsData.events.length} events`, {
        transactions: eventsData.transactions.length,
        events: eventsData.events.length
      });
      
      console.log(`   ‚úÖ Found ${eventsData.events.length} events`);
      console.log(`   ‚úÖ Found ${eventsData.transactions.length} transactions`);

      // Step 4: Extract accounts and blocks
      this._emitProgress('processing', 70, 'Extracting accounts and blocks...');
      console.log(`\nüîç Step 2/3: Extracting accounts and blocks...`);
      
      eventsData.transactions.forEach(tx => {
        if (tx.from) results.accounts.add(tx.from.toLowerCase());
        if (tx.to) results.accounts.add(tx.to.toLowerCase());
        if (tx.blockNumber) results.blocks.add(tx.blockNumber);
      });
      
      results.metrics.uniqueAccounts = results.accounts.size;
      results.metrics.uniqueBlocks = results.blocks.size;
      
      this._emitProgress('processing', 80, `Extracted ${results.accounts.size} accounts and ${results.blocks.size} blocks`, {
        accounts: results.accounts.size,
        blocks: results.blocks.size
      });
      
      console.log(`   ‚úÖ Found ${results.accounts.size} unique accounts`);
      console.log(`   ‚úÖ Found ${results.blocks.size} unique blocks`);

      // Step 5: Detect contract deployment
      this._emitProgress('deployment', 90, 'Detecting contract deployment...');
      console.log(`\nüîç Step 3/3: Detecting contract deployment...`);
      
      const deploymentInfo = await this._detectDeployment(contractAddress, chain, fromBlock, eventsData.transactions);
      results.deploymentInfo = deploymentInfo;
      
      if (deploymentInfo.found) {
        this._emitProgress('deployment', 95, 'Deployment detected!', {
          deploymentDate: deploymentInfo.date,
          deploymentBlock: deploymentInfo.blockNumber
        });
        console.log(`   ‚úÖ Deployment detected!`);
        console.log(`      üìÖ Date: ${deploymentInfo.date}`);
        console.log(`      üß± Block: ${deploymentInfo.blockNumber.toLocaleString()}`);
        console.log(`      üîó Tx: ${deploymentInfo.transactionHash}`);
        console.log(`      üë§ Deployer: ${deploymentInfo.deployer}`);
      } else {
        this._emitProgress('deployment', 95, 'Deployment not found in scanned range');
        console.log(`   ‚ö†Ô∏è  Deployment not found in scanned range`);
        console.log(`      üí° Contract likely deployed before block ${fromBlock.toLocaleString()}`);
      }

      // Calculate scan duration
      results.metrics.scanDuration = (Date.now() - startTime) / 1000;

      // Final progress
      this._emitProgress('complete', 100, 'Quick scan complete!', {
        transactions: results.metrics.totalTransactions,
        events: results.metrics.totalEvents,
        accounts: results.metrics.uniqueAccounts,
        blocks: results.metrics.uniqueBlocks,
        duration: results.metrics.scanDuration
      });

      // Print summary
      console.log(`\nüìä QUICK SCAN SUMMARY`);
      console.log('========================================================');
      console.log(`‚è±Ô∏è  Duration: ${results.metrics.scanDuration.toFixed(2)}s`);
      console.log(`üìù Transactions: ${results.metrics.totalTransactions}`);
      console.log(`üìã Events: ${results.metrics.totalEvents}`);
      console.log(`üë• Accounts: ${results.metrics.uniqueAccounts}`);
      console.log(`üß± Blocks: ${results.metrics.uniqueBlocks}`);
      console.log(`üìÖ Deployment: ${deploymentInfo.found ? deploymentInfo.date : 'Not found in range'}`);
      console.log(`‚úÖ Data Quality: ${results.metrics.dataQuality}`);

      return results;

    } catch (error) {
      console.error(`‚ùå Quick scan failed: ${error.message}`);
      results.metrics.scanDuration = (Date.now() - startTime) / 1000;
      results.metrics.dataQuality = 'error';
      throw error;
    }
  }

  /**
   * Fetch contract events efficiently
   * @private
   */
  async _fetchContractEvents(contractAddress, fromBlock, toBlock, chain) {
    try {
      console.log(`   üîÑ Calling fetcher.fetchTransactions...`);
      // fetchTransactions already returns full transaction data with events
      const transactions = await this.fetcher.fetchTransactions(contractAddress, fromBlock, toBlock, chain);
      
      console.log(`   üìä Received ${transactions.length} transactions from fetcher`);
      
      // Extract events from transactions
      const allEvents = [];
      transactions.forEach(tx => {
        if (tx.events && Array.isArray(tx.events)) {
          allEvents.push(...tx.events);
        }
      });

      console.log(`   üìä Extracted ${allEvents.length} events from transactions`);

      return {
        events: allEvents,
        transactions: transactions // Already have full transaction details
      };
    } catch (error) {
      console.error(`   ‚ùå Event fetching failed: ${error.message}`);
      console.error(`   Stack: ${error.stack}`);
      return { events: [], transactions: [] };
    }
  }

  /**
   * Batch fetch transaction details
   * @private
   */
  async _batchFetchTransactions(txHashes, chain) {
    const transactions = [];
    const batchSize = this.config.batchSize;

    for (let i = 0; i < txHashes.length; i += batchSize) {
      const batch = txHashes.slice(i, i + batchSize);
      
      const batchPromises = batch.map(async (txHash) => {
        try {
          const receipt = await this.fetcher.fetchTransactionReceipt(txHash, chain);
          return receipt;
        } catch (error) {
          console.warn(`   ‚ö†Ô∏è  Failed to fetch tx ${txHash}: ${error.message}`);
          return null;
        }
      });

      const batchResults = await Promise.all(batchPromises);
      transactions.push(...batchResults.filter(tx => tx !== null));

      // Progress indicator
      if (txHashes.length > batchSize) {
        const progress = Math.min(100, ((i + batchSize) / txHashes.length * 100)).toFixed(0);
        process.stdout.write(`\r   Progress: ${progress}%`);
      }
    }

    if (txHashes.length > batchSize) {
      process.stdout.write(`\r   Progress: 100%\n`);
    }

    return transactions;
  }

  /**
   * Detect contract deployment date and info
   * @private
   */
  async _detectDeployment(contractAddress, chain, fromBlock, transactions = []) {
    try {
      console.log(`   üîç Searching for deployment transaction...`);

      // Use provided transactions if available
      if (transactions.length > 0) {
        // Sort by block number to find earliest
        const sorted = transactions.sort((a, b) => a.blockNumber - b.blockNumber);
        const earliest = sorted[0];
        
        // Check if this is a contract creation (to field is null or contract address)
        if (!earliest.to || earliest.to.toLowerCase() === contractAddress.toLowerCase()) {
          return {
            found: true,
            blockNumber: earliest.blockNumber,
            transactionHash: earliest.hash,
            deployer: earliest.from,
            date: new Date(earliest.blockTimestamp * 1000).toISOString(),
            timestamp: earliest.blockTimestamp
          };
        }
      }

      // Fallback: Check if contract code exists
      console.log(`   üîç Checking contract code existence...`);
      const hasCode = await this._checkContractCode(contractAddress, chain);
      
      if (hasCode) {
        return {
          found: false,
          message: 'Contract exists but deployment not found in scanned range',
          estimatedDeployment: 'Before scanned blocks',
          contractExists: true
        };
      }

      return {
        found: false,
        message: 'Contract not found or not deployed yet',
        contractExists: false
      };

    } catch (error) {
      console.warn(`   ‚ö†Ô∏è  Deployment detection failed: ${error.message}`);
      return {
        found: false,
        error: error.message
      };
    }
  }

  /**
   * Binary search for deployment transaction
   * @private
   */
  async _binarySearchDeployment(contractAddress, chain, startBlock, endBlock) {
    // For quick scan, we'll check the first transaction in our scanned events
    // Full binary search would be too slow for quick scan
    try {
      // Get the earliest transaction we found
      const result = await this.fetcher.fetchTransactions(contractAddress, startBlock, endBlock, chain);
      
      if (result.length > 0) {
        // Sort by block number to find earliest
        const sorted = result.sort((a, b) => a.blockNumber - b.blockNumber);
        const earliest = sorted[0];
        
        // Check if this is a contract creation (to field is null or contract address)
        if (!earliest.to || earliest.to.toLowerCase() === contractAddress.toLowerCase()) {
          return {
            hash: earliest.hash,
            blockNumber: earliest.blockNumber,
            from: earliest.from,
            timestamp: earliest.blockTimestamp || Math.floor(Date.now() / 1000)
          };
        }
      }
      
      return null;
    } catch (error) {
      console.warn(`   ‚ö†Ô∏è  Binary search failed: ${error.message}`);
      return null;
    }
  }

  /**
   * Check if contract has code deployed
   * @private
   */
  async _checkContractCode(contractAddress, chain) {
    try {
      // This would require eth_getCode RPC call
      // For now, we'll assume contract exists if we found any events
      return true;
    } catch (error) {
      return false;
    }
  }

  /**
   * Get scan statistics
   */
  getStats(results) {
    return {
      efficiency: {
        transactionsPerSecond: (results.metrics.totalTransactions / results.metrics.scanDuration).toFixed(2),
        eventsPerSecond: (results.metrics.totalEvents / results.metrics.scanDuration).toFixed(2),
        blocksPerSecond: (results.metrics.uniqueBlocks / results.metrics.scanDuration).toFixed(2)
      },
      coverage: {
        blockRange: results.metrics.blockRange,
        totalBlocks: results.metrics.blockRange.to - results.metrics.blockRange.from,
        daysScanned: ((results.metrics.blockRange.to - results.metrics.blockRange.from) / 7200).toFixed(1) // Assuming 12 sec blocks
      },
      quality: {
        dataQuality: results.metrics.dataQuality,
        completeness: results.metrics.totalTransactions > 0 ? 'complete' : 'empty',
        deploymentDetected: results.deploymentInfo?.found || false
      }
    };
  }
}

export default OptimizedQuickScan;
